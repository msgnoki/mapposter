<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Poster Generator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            overflow: hidden;
        }

        #map {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Cadre fixe au centre */
        #frame-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid #e74c3c;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            z-index: 400;
            transition: all 0.3s ease;
        }

        /* Marqueur croix au centre du cadre */
        #center-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
        }

        #center-marker::before,
        #center-marker::after {
            content: '';
            position: absolute;
            background: #e74c3c;
        }

        #center-marker::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        #center-marker::after {
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }

        /* Panneau lat√©ral */
        #sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 380px;
            height: 100%;
            background: white;
            box-shadow: 4px 0 16px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        #sidebar.collapsed {
            transform: translateX(-340px);
        }

        #sidebar-toggle {
            position: absolute;
            right: -40px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: white;
            border: none;
            border-radius: 0 8px 8px 0;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .sidebar-header {
            padding: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .sidebar-header h1 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .sidebar-header p {
            font-size: 13px;
            opacity: 0.9;
        }

        .sidebar-section {
            padding: 20px 24px;
            border-bottom: 1px solid #e0e0e0;
        }

        .sidebar-section h3 {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            color: #666;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .location-info {
            background: #f5f5f5;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        .location-info strong {
            display: block;
            font-size: 16px;
            margin-bottom: 4px;
            color: #333;
        }

        /* Th√®mes */
        .theme-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        .theme-checkbox {
            display: flex;
            align-items: center;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }

        .theme-checkbox:hover {
            background: #f5f5f5;
            border-color: #667eea;
        }

        .theme-checkbox input[type="checkbox"] {
            margin-right: 8px;
        }

        .select-all-themes {
            margin-bottom: 12px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            display: flex;
            align-items: center;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        .select-all-themes input {
            margin-right: 8px;
        }

        /* Format et orientation */
        .format-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .format-btn {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            text-align: left;
        }

        .format-btn:hover {
            border-color: #667eea;
            background: #f5f5ff;
        }

        .format-btn.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .orientation-toggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }

        /* Contr√¥les */
        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 6px;
            color: #555;
        }

        .control-group select,
        .control-group input[type="number"],
        .control-group input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .control-group input[type="text"]:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Bouton de g√©n√©ration */
        .generate-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(102, 126, 234, 0.4);
        }

        .generate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .generate-btn.loading {
            background: #999;
        }

        /* Messages */
        .message {
            margin-top: 12px;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            display: none;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Info carte */
        .map-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 500;
            font-size: 13px;
        }

        .map-info div {
            margin: 4px 0;
        }

        /* Scrollbar personnalis√©e */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <!-- Carte -->
    <div id="map"></div>

    <!-- Cadre fixe -->
    <div id="frame-overlay">
        <div id="center-marker"></div>
    </div>

    <!-- Info carte -->
    <div class="map-info">
        <div><strong>Zone s√©lectionn√©e</strong></div>
        <div id="map-center">Centre: 43.4255, 6.7694</div>
        <div id="map-distance">Distance: 12000m</div>
    </div>

    <!-- Panneau lat√©ral -->
    <div id="sidebar">
        <button id="sidebar-toggle">‚óÄ</button>

        <div class="sidebar-header">
            <h1>üó∫Ô∏è Map Poster Generator</h1>
            <p>S√©lectionnez une zone et personnalisez votre poster</p>
        </div>

        <!-- Localisation -->
        <div class="sidebar-section">
            <h3>üìç Localisation</h3>
            <div class="control-group">
                <label>Nom de la ville</label>
                <input type="text" id="location-city" value="Saint-Rapha√´l"
                       placeholder="Nom de la ville">
            </div>
            <div class="control-group">
                <label>Label pays (affich√© sur le poster)</label>
                <input type="text" id="location-country" value="French Riviera"
                       placeholder="ex: French Riviera, France, etc.">
            </div>
        </div>

        <!-- Th√®mes -->
        <div class="sidebar-section">
            <h3>üé® Th√®mes</h3>
            <div class="select-all-themes">
                <input type="checkbox" id="select-all" checked onchange="toggleAllThemes()">
                <label for="select-all" style="cursor: pointer;">Tout s√©lectionner</label>
            </div>
            <div class="theme-grid">
                {% for theme in themes %}
                <label class="theme-checkbox">
                    <input type="checkbox" name="theme" value="{{ theme }}" checked>
                    <span>{{ theme }}</span>
                </label>
                {% endfor %}
            </div>
        </div>

        <!-- Format -->
        <div class="sidebar-section">
            <h3>üìê Format</h3>
            <div class="format-grid">
                {% for key, preset in format_presets.items() %}
                <button class="format-btn {% if key == 'A' %}active{% endif %}"
                        data-format="{{ key }}"
                        data-width="{{ preset.width }}"
                        data-height="{{ preset.height }}"
                        onclick="selectFormat('{{ key }}', {{ preset.width }}, {{ preset.height }})">
                    <div style="font-weight: 600;">{{ preset.name.split('(')[0].strip() }}</div>
                    {% if key != 'custom' %}
                    <div style="font-size: 11px; opacity: 0.7; margin-top: 2px;">
                        {{ "%.1f"|format(preset.width) }} √ó {{ "%.1f"|format(preset.height) }}"
                    </div>
                    {% endif %}
                </button>
                {% endfor %}
            </div>

            <!-- Custom dimensions -->
            <div id="custom-dimensions" style="display: none; margin-top: 12px; gap: 8px; grid-template-columns: 1fr 1fr;">
                <div class="control-group" style="margin-bottom: 0;">
                    <label>Largeur (inches)</label>
                    <input type="number" id="custom-width" min="4" max="48" step="0.1" value="12" oninput="updateCustomDimensions()">
                </div>
                <div class="control-group" style="margin-bottom: 0;">
                    <label>Hauteur (inches)</label>
                    <input type="number" id="custom-height" min="4" max="48" step="0.1" value="16" oninput="updateCustomDimensions()">
                </div>
            </div>

            <!-- Orientation -->
            <div class="orientation-toggle">
                <button class="format-btn active" onclick="setOrientation('portrait')">
                    üìÑ Portrait
                </button>
                <button class="format-btn" onclick="setOrientation('landscape')">
                    üìÉ Paysage
                </button>
            </div>
        </div>

        <!-- Configuration -->
        <div class="sidebar-section">
            <h3>‚öôÔ∏è Configuration</h3>

            <div class="control-group">
                <label>Format de sortie</label>
                <select id="output-format">
                    <option value="pdf">PDF Vectoriel</option>
                    <option value="png">PNG (Raster)</option>
                    <option value="svg">SVG (Vectoriel)</option>
                </select>
            </div>

            <div class="control-group">
                <label>R√©solution (DPI)</label>
                <select id="dpi">
                    <option value="150">150 DPI (Aper√ßu)</option>
                    <option value="300" selected>300 DPI (Standard)</option>
                    <option value="600">600 DPI (Haute qualit√©)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Hauteur du d√©grad√© (blur) <span id="gradient-value">25%</span></label>
                <input type="range" id="gradient-height" min="0" max="50" value="25" step="1"
                       oninput="document.getElementById('gradient-value').textContent = this.value + '%'"
                       style="width: 100%;">
                <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">
                    0% = Aucun blur, 50% = Maximum
                </div>
            </div>
        </div>

        <!-- G√©n√©ration -->
        <div class="sidebar-section">
            <button class="generate-btn" id="generate-btn" onclick="generatePosters()">
                üöÄ G√©n√©rer les posters
            </button>
            <button class="generate-btn" id="stop-btn" onclick="stopGeneration()" style="display: none; background: #e74c3c;">
                üõë Arr√™ter la g√©n√©ration
            </button>
            <div class="message" id="message"></div>
        </div>

        <!-- Logs de g√©n√©ration -->
        <div class="sidebar-section" id="logs-section" style="display: none;">
            <h3>üìã Logs en temps r√©el</h3>
            <div id="generation-logs" style="
                background: #1e1e1e;
                color: #00ff00;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 12px;
                border-radius: 6px;
                max-height: 200px;
                overflow-y: auto;
                white-space: pre-wrap;
                word-wrap: break-word;
            "></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // √âtat global
        let map;
        let currentFormat = { width: 11.7, height: 16.5 };
        let currentOrientation = 'portrait';
        let currentLocation = { lat: 43.4255303, lng: 6.7694244, city: 'Saint-Rapha√´l', country: 'France' };

        // Initialiser la carte
        function initMap() {
            map = L.map('map', {
                zoomDelta: 0.25,           // Zoom par incr√©ments de 0.25 (au lieu de 1)
                zoomSnap: 0.25,            // Permettre des niveaux de zoom fractionnaires
                wheelPxPerZoomLevel: 120   // Plus de pixels n√©cessaires = zoom plus doux
            }).setView([currentLocation.lat, currentLocation.lng], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Mettre √† jour le cadre quand la carte bouge
            map.on('move', updateFrame);
            map.on('zoom', updateFrame);
            map.on('moveend', updateLocation);

            updateFrame();
        }

        // Mettre √† jour le cadre fixe
        function updateFrame() {
            const frame = document.getElementById('frame-overlay');
            const mapSize = map.getSize();

            // Dimensions du poster apr√®s rotation selon l'orientation
            let posterWidth = currentFormat.width;
            let posterHeight = currentFormat.height;
            if (currentOrientation === 'landscape') {
                [posterWidth, posterHeight] = [posterHeight, posterWidth];
            }

            // Calculer la taille du cadre en pixels bas√© sur le ratio du poster
            const ratio = posterHeight / posterWidth;

            let frameWidth, frameHeight;

            // Ajuster la taille du cadre selon l'orientation
            if (currentOrientation === 'portrait') {
                frameWidth = Math.min(mapSize.x * 0.3, 300);
                frameHeight = frameWidth * ratio;
            } else {
                frameHeight = Math.min(mapSize.y * 0.4, 250);
                frameWidth = frameHeight * ratio;
            }

            frame.style.width = frameWidth + 'px';
            frame.style.height = frameHeight + 'px';

            // Mettre √† jour les infos
            updateMapInfo();
        }

        // Calculer les bounds r√©els du cadre
        function getFrameBounds() {
            const frame = document.getElementById('frame-overlay');
            const frameRect = frame.getBoundingClientRect();
            const mapContainer = document.getElementById('map');
            const mapRect = mapContainer.getBoundingClientRect();

            // üîç DEBUG: Positions du cadre
            console.log('üîç [FRAME] Positions:', {
                frameRect: {
                    left: frameRect.left,
                    top: frameRect.top,
                    width: frameRect.width,
                    height: frameRect.height
                },
                mapRect: {
                    left: mapRect.left,
                    top: mapRect.top,
                    width: mapRect.width,
                    height: mapRect.height
                }
            });

            // Convertir les pixels du cadre en coordonn√©es map (offset en cas de sidebar)
            const frameCenter = {
                x: frameRect.left + frameRect.width / 2 - mapRect.left,
                y: frameRect.top + frameRect.height / 2 - mapRect.top
            };

            console.log('üîç [FRAME] Centre pixels:', frameCenter);

            const frameHalfWidth = frameRect.width / 2;
            const frameHalfHeight = frameRect.height / 2;

            // Points du cadre
            const topLeft = map.containerPointToLatLng([frameCenter.x - frameHalfWidth, frameCenter.y - frameHalfHeight]);
            const topRight = map.containerPointToLatLng([frameCenter.x + frameHalfWidth, frameCenter.y - frameHalfHeight]);
            const bottomLeft = map.containerPointToLatLng([frameCenter.x - frameHalfWidth, frameCenter.y + frameHalfHeight]);
            const center = map.containerPointToLatLng([frameCenter.x, frameCenter.y]);

            console.log('üîç [FRAME] Centre g√©o:', center);

            // Calculer les distances depuis le centre
            const distNS = map.distance(center, [topLeft.lat, center.lng]);
            const distEW = map.distance(center, [center.lat, topRight.lng]);

            console.log('üîç [FRAME] Distances brutes:', { distNS, distEW });

            // create_poster utilise dist comme la PLUS GRANDE dimension
            // Portrait: hauteur > largeur ‚Üí utiliser distNS
            // Landscape: largeur > hauteur ‚Üí utiliser distEW
            const frameDistance = currentOrientation === 'portrait'
                ? Math.round(distNS)  // Portrait: rayon vertical
                : Math.round(distEW); // Landscape: rayon horizontal

            // Dimensions du poster apr√®s rotation selon l'orientation
            let posterWidth = currentFormat.width;
            let posterHeight = currentFormat.height;
            if (currentOrientation === 'landscape') {
                [posterWidth, posterHeight] = [posterHeight, posterWidth];
            }

            // Compenser pour le facteur backend (compensated_dist calculation)
            const compensationFactor = (Math.max(posterWidth, posterHeight) /
                                       Math.min(posterWidth, posterHeight)) / 4;

            const distanceForBackend = Math.round(frameDistance / compensationFactor);

            console.log('üîç [FRAME] Distances finales:', {
                frameDistance,
                compensationFactor: compensationFactor.toFixed(2),
                distanceForBackend,
                orientation: currentOrientation,
                format: `${currentFormat.width}x${currentFormat.height}`
            });

            return {
                distance: distanceForBackend,
                frameDistance: frameDistance,
                bounds: { topLeft, topRight, bottomLeft, center }
            };
        }

        // Mettre √† jour les informations de la carte
        function updateMapInfo() {
            const frameBounds = getFrameBounds();

            document.getElementById('map-center').textContent =
                `Centre: ${frameBounds.bounds.center.lat.toFixed(4)}, ${frameBounds.bounds.center.lng.toFixed(4)}`;
            document.getElementById('map-distance').textContent =
                `Rayon: ${frameBounds.distance}m`;

            console.log('üìä [MAP-INFO] Mis √† jour');
        }

        // Reverse geocoding pour obtenir le lieu
        async function updateLocation() {
            const frameBounds = getFrameBounds();
            const center = frameBounds.bounds.center;

            try {
                const response = await fetch('/api/geocode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lat: center.lat, lng: center.lng })
                });

                if (response.ok) {
                    const data = await response.json();
                    currentLocation = {
                        lat: center.lat,
                        lng: center.lng,
                        city: data.city,
                        country: data.country
                    };

                    // Mettre √† jour les champs input
                    document.getElementById('location-city').value = data.city;
                    document.getElementById('location-country').value = data.country;
                }
            } catch (error) {
                console.error('Geocoding error:', error);
            }
        }

        // S√©lectionner un format
        function selectFormat(format, width, height) {
            document.querySelectorAll('.format-btn[data-format]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-format="${format}"]`).classList.add('active');

            // Afficher/masquer les dimensions personnalis√©es
            const customDimensions = document.getElementById('custom-dimensions');
            if (format === 'custom') {
                customDimensions.style.display = 'grid';
                // Lire les valeurs des inputs
                width = parseFloat(document.getElementById('custom-width').value) || 12;
                height = parseFloat(document.getElementById('custom-height').value) || 16;
            } else {
                customDimensions.style.display = 'none';
            }

            currentFormat = { width, height };
            updateFrame();
        }

        // Mettre √† jour le format quand les dimensions custom changent
        function updateCustomDimensions() {
            const formatBtn = document.querySelector('.format-btn.active[data-format]');
            if (formatBtn && formatBtn.dataset.format === 'custom') {
                const width = parseFloat(document.getElementById('custom-width').value) || 12;
                const height = parseFloat(document.getElementById('custom-height').value) || 16;
                currentFormat = { width, height };
                updateFrame();
            }
        }

        // Changer l'orientation
        function setOrientation(orientation) {
            document.querySelectorAll('.orientation-toggle .format-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            currentOrientation = orientation;
            updateFrame();
        }

        // Tout s√©lectionner/d√©s√©lectionner
        function toggleAllThemes() {
            const selectAll = document.getElementById('select-all');
            const checkboxes = document.querySelectorAll('input[name="theme"]');
            checkboxes.forEach(cb => cb.checked = selectAll.checked);
        }

        // Toggle sidebar
        document.getElementById('sidebar-toggle').addEventListener('click', function() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            this.textContent = sidebar.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
        });

        // Ajouter un log dans la console web
        function addLog(text) {
            const logsDiv = document.getElementById('generation-logs');
            const timestamp = new Date().toLocaleTimeString();
            logsDiv.textContent += `[${timestamp}] ${text}\n`;
            logsDiv.scrollTop = logsDiv.scrollHeight;  // Auto-scroll to bottom
        }

        // Arr√™ter la g√©n√©ration
        async function stopGeneration() {
            addLog('üõë Envoi demande d\'annulation...');
            try {
                const response = await fetch('/api/cancel', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();
                addLog('‚úì Annulation envoy√©e au serveur');
                document.getElementById('stop-btn').disabled = true;
            } catch (error) {
                addLog('‚ùå Erreur lors de l\'annulation: ' + error.message);
            }
        }

        // G√©n√©rer les posters
        async function generatePosters() {
            console.log('\nüöÄ [GENERATE] ========== D√âBUT G√âN√âRATION ==========');

            const generateBtn = document.getElementById('generate-btn');
            const stopBtn = document.getElementById('stop-btn');
            const message = document.getElementById('message');
            const logsSection = document.getElementById('logs-section');
            const logsDiv = document.getElementById('generation-logs');

            // V√©rifier qu'au moins un th√®me est s√©lectionn√©
            const selectedThemes = Array.from(document.querySelectorAll('input[name="theme"]:checked'))
                .map(cb => cb.value);

            console.log('üé® [GENERATE] Th√®mes s√©lectionn√©s:', selectedThemes);

            if (selectedThemes.length === 0) {
                console.warn('‚ö†Ô∏è [GENERATE] Aucun th√®me s√©lectionn√©');
                showMessage('Veuillez s√©lectionner au moins un th√®me', 'error');
                return;
            }

            // Afficher les logs et le bouton stop
            logsDiv.textContent = '';  // Clear previous logs
            logsSection.style.display = 'block';
            generateBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            stopBtn.disabled = false;

            addLog(`üöÄ D√©but g√©n√©ration de ${selectedThemes.length} poster(s)`);
            showMessage(`‚è≥ G√©n√©ration en cours...`, 'success');
            message.style.display = 'block';

            try {
                const frameBounds = getFrameBounds();
                const center = frameBounds.bounds.center;

                console.log('üìç [GENERATE] Centre du cadre:', center);

                // R√©cup√©rer les valeurs des champs
                const cityValue = document.getElementById('location-city').value || currentLocation.city;
                const countryValue = document.getElementById('location-country').value || currentLocation.country;

                console.log('üèôÔ∏è [GENERATE] Ville/Pays:', { cityValue, countryValue });

                const formatBtn = document.querySelector('.format-btn.active[data-format]');
                const formatKey = formatBtn?.dataset.format || 'A';
                let width = currentFormat.width;
                let height = currentFormat.height;
                if (currentOrientation === 'landscape') {
                    [width, height] = [height, width];
                }

                console.log('üìê [GENERATE] Format:', {
                    preset: formatKey,
                    width,
                    height,
                    orientation: currentOrientation
                });

                // frameBounds.distance est D√âJ√Ä compens√© (calcul√© dans getFrameBounds)
                // Ne PAS diviser √† nouveau par compensationFactor!
                const distanceForBackend = frameBounds.distance;

                console.log('üìè [GENERATE] Distance utilis√©e:', {
                    frameDistance: frameBounds.frameDistance,
                    distanceForBackend: distanceForBackend
                });

                const data = {
                    city: cityValue,
                    country: 'France', // Pour le g√©ocodage
                    lat: center.lat,
                    lng: center.lng,
                    distance: distanceForBackend, // Distance d√©j√† compens√©e depuis getFrameBounds()
                    themes: selectedThemes,
                    format_preset: formatKey,
                    orientation: currentOrientation,
                    output_format: document.getElementById('output-format').value,
                    dpi: document.getElementById('dpi').value,
                    country_label: countryValue,
                    custom_width: formatKey === 'custom' ? width : null,
                    custom_height: formatKey === 'custom' ? height : null,
                    gradient_height: parseFloat(document.getElementById('gradient-height').value) / 100  // % ‚Üí decimal
                };

                console.log('üì¶ [GENERATE] Donn√©es envoy√©es au backend:', data);

                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                console.log('üîÑ [GENERATE] R√©ponse HTTP:', response.status, response.statusText);

                const result = await response.json();

                console.log('‚úÖ [GENERATE] R√©sultat:', result);

                if (result.success) {
                    console.log('‚úÖ [GENERATE] ========== G√âN√âRATION R√âUSSIE ==========\n');
                    addLog(`‚úÖ Termin√©! ${result.message}`);
                    showMessage(`‚úÖ ${result.message}`, 'success');
                } else if (result.cancelled) {
                    console.log('üõë [GENERATE] ========== G√âN√âRATION ANNUL√âE ==========\n');
                    addLog(`üõë ${result.message}`);
                    showMessage(`üõë ${result.message}`, 'error');
                } else {
                    console.error('‚ùå [GENERATE] Erreur backend:', result.error);
                    addLog(`‚ùå Erreur: ${result.error}`);
                    showMessage(`‚ùå Erreur: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('‚ùå [GENERATE] Exception:', error);
                addLog(`‚ùå Exception: ${error.message}`);
                showMessage(`‚ùå Erreur: ${error.message}`, 'error');
            } finally {
                // Restaurer les boutons
                generateBtn.style.display = 'block';
                stopBtn.style.display = 'none';
                generateBtn.disabled = false;
            }
        }

        function showMessage(text, type) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.className = `message ${type}`;
            message.style.display = 'block';
        }

        // Initialiser au chargement
        window.addEventListener('load', function() {
            initMap();
            updateLocation();
        });
    </script>
</body>
</html>
